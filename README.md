# Реализация БПФ на C с использованием средств стандартной библиотеки и OpenMP для многопоточного выполнения кода
___
За основу реализации взят алгоритм [Кули-Тьюки](https://en.wikipedia.org/wiki/Cooley–Tukey_FFT_algorithm), основанный на двоично-инверсной перестановке.

В процессе работы используются небольшие алиасы:
* true -> 1;
* false -> 0;
* cx_size -> sizeof(cplx);
* cplx -> double complex.
___

Реализация поделена на функции, которые разделяются на публичные (snake_case) и приватные (_underlined_snake_case):
* `_rev(unsigned n, unsigned N)` - функция для двоично инверсной перестановки числа n, состоящего из N битов;
* `rev(unsigned n)` - фасад функции _rev, внутри считается количество битов для инверсирования;
* `_power(unsigned n)` - функция, которая возрващает степень 2 для указанного числа или завершает работу программы, если число не является степенью двойки. Это необходимо, так как для работы алгоритма требуется вектор длиной 2^n чисел;
* `bit_reverse_copy(cplx a[], unsigned n)` - возвращает новый массив длины n, созданные после двоично-инверсной перестановки.
* `show(const char *s, cplx buf[], unsigned n)` - простая функция для вывода на экран сообщения и всех элементов массива;
* `_fft(cplx *array, unsigned n, short invert)` - основной алгоритм, возвращающий результат fft, если `invert == false`, и ifft, если `invert == true`;
* `fft(cplx *array, unsigned n)` - фасад для алгоритма, вызывает `_fft(array, n, false)`;
* `ifft(cplx *array, unsigned n)` - фасад для алгоритма, вызывает `_fft(array, n, true)`.

## Команда сборки
Поскольку в проект добавлены библиотеки <math.h> и <omp.h>, то для компиляции необходимо указать два дополнительных флага, так же для улучшения производительности используется флаг оптимизации второго уровня: `gcc -fopenmp main.c -lm -O2` - после появится файл a.out в директории сборки, который можно запустить `./a.out`.